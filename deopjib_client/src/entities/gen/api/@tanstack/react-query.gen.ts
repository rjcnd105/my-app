// This file is auto-generated by @hey-api/openapi-ts

import { type Options, getApiJsonPayItem, postApiJsonPayItem, postApiJsonPayItemUpsertFromWords, getApiJsonPayers, getApiJsonRooms, getApiJsonRoomsByIdById, getApiJsonRoomsByShortIdByShortId, patchApiJsonRoomsName, postApiJsonRoomsUpsertWithPayers, getApiJsonRoomsByIdPayers } from '../sdk.gen';
import { queryOptions, infiniteQueryOptions, type InfiniteData, type UseMutationOptions } from '@tanstack/react-query';
import type { GetApiJsonPayItemData, GetApiJsonPayItemError, GetApiJsonPayItemResponse, PostApiJsonPayItemData, PostApiJsonPayItemError, PostApiJsonPayItemResponse, PostApiJsonPayItemUpsertFromWordsData, PostApiJsonPayItemUpsertFromWordsError, PostApiJsonPayItemUpsertFromWordsResponse, GetApiJsonPayersData, GetApiJsonPayersError, GetApiJsonPayersResponse, GetApiJsonRoomsData, GetApiJsonRoomsByIdByIdData, GetApiJsonRoomsByShortIdByShortIdData, PatchApiJsonRoomsNameData, PatchApiJsonRoomsNameError, PatchApiJsonRoomsNameResponse, PostApiJsonRoomsUpsertWithPayersData, PostApiJsonRoomsUpsertWithPayersError, PostApiJsonRoomsUpsertWithPayersResponse, GetApiJsonRoomsByIdPayersData } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: readonly string[];
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: readonly string[]): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getApiJsonPayItemQueryKey = (options?: Options<GetApiJsonPayItemData>) => createQueryKey('getApiJsonPayItem', options);

/**
 * /pay_item operation on pay_item resource
 */
export const getApiJsonPayItemOptions = (options?: Options<GetApiJsonPayItemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiJsonPayItem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiJsonPayItemQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getApiJsonPayItemInfiniteQueryKey = (options?: Options<GetApiJsonPayItemData>): QueryKey<Options<GetApiJsonPayItemData>> => createQueryKey('getApiJsonPayItem', options, true);

/**
 * /pay_item operation on pay_item resource
 */
export const getApiJsonPayItemInfiniteOptions = (options?: Options<GetApiJsonPayItemData>) => {
    return infiniteQueryOptions<GetApiJsonPayItemResponse, GetApiJsonPayItemError, InfiniteData<GetApiJsonPayItemResponse>, QueryKey<Options<GetApiJsonPayItemData>>, {
    after?: string;
    before?: string;
    count?: boolean;
    limit?: number;
    offset?: number;
} | Pick<QueryKey<Options<GetApiJsonPayItemData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetApiJsonPayItemData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getApiJsonPayItem({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiJsonPayItemInfiniteQueryKey(options)
    });
};

/**
 * /pay_item operation on pay_item resource
 */
export const postApiJsonPayItemMutation = (options?: Partial<Options<PostApiJsonPayItemData>>): UseMutationOptions<PostApiJsonPayItemResponse, PostApiJsonPayItemError, Options<PostApiJsonPayItemData>> => {
    const mutationOptions: UseMutationOptions<PostApiJsonPayItemResponse, PostApiJsonPayItemError, Options<PostApiJsonPayItemData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiJsonPayItem({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * /pay_item/upsert_from_words operation on pay_item resource
 */
export const postApiJsonPayItemUpsertFromWordsMutation = (options?: Partial<Options<PostApiJsonPayItemUpsertFromWordsData>>): UseMutationOptions<PostApiJsonPayItemUpsertFromWordsResponse, PostApiJsonPayItemUpsertFromWordsError, Options<PostApiJsonPayItemUpsertFromWordsData>> => {
    const mutationOptions: UseMutationOptions<PostApiJsonPayItemUpsertFromWordsResponse, PostApiJsonPayItemUpsertFromWordsError, Options<PostApiJsonPayItemUpsertFromWordsData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiJsonPayItemUpsertFromWords({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiJsonPayersQueryKey = (options?: Options<GetApiJsonPayersData>) => createQueryKey('getApiJsonPayers', options);

/**
 * /payers operation on payer resource
 */
export const getApiJsonPayersOptions = (options?: Options<GetApiJsonPayersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiJsonPayers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiJsonPayersQueryKey(options)
    });
};

export const getApiJsonPayersInfiniteQueryKey = (options?: Options<GetApiJsonPayersData>): QueryKey<Options<GetApiJsonPayersData>> => createQueryKey('getApiJsonPayers', options, true);

/**
 * /payers operation on payer resource
 */
export const getApiJsonPayersInfiniteOptions = (options?: Options<GetApiJsonPayersData>) => {
    return infiniteQueryOptions<GetApiJsonPayersResponse, GetApiJsonPayersError, InfiniteData<GetApiJsonPayersResponse>, QueryKey<Options<GetApiJsonPayersData>>, {
    after?: string;
    before?: string;
    count?: boolean;
    limit?: number;
    offset?: number;
} | Pick<QueryKey<Options<GetApiJsonPayersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetApiJsonPayersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getApiJsonPayers({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiJsonPayersInfiniteQueryKey(options)
    });
};

export const getApiJsonRoomsQueryKey = (options?: Options<GetApiJsonRoomsData>) => createQueryKey('getApiJsonRooms', options);

/**
 * /rooms operation on room resource
 */
export const getApiJsonRoomsOptions = (options?: Options<GetApiJsonRoomsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiJsonRooms({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiJsonRoomsQueryKey(options)
    });
};

export const getApiJsonRoomsByIdByIdQueryKey = (options: Options<GetApiJsonRoomsByIdByIdData>) => createQueryKey('getApiJsonRoomsByIdById', options);

/**
 * /rooms/by_id/:id operation on room resource
 */
export const getApiJsonRoomsByIdByIdOptions = (options: Options<GetApiJsonRoomsByIdByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiJsonRoomsByIdById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiJsonRoomsByIdByIdQueryKey(options)
    });
};

export const getApiJsonRoomsByShortIdByShortIdQueryKey = (options: Options<GetApiJsonRoomsByShortIdByShortIdData>) => createQueryKey('getApiJsonRoomsByShortIdByShortId', options);

/**
 * /rooms/by_short_id/:short_id operation on room resource
 */
export const getApiJsonRoomsByShortIdByShortIdOptions = (options: Options<GetApiJsonRoomsByShortIdByShortIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiJsonRoomsByShortIdByShortId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiJsonRoomsByShortIdByShortIdQueryKey(options)
    });
};

/**
 * /rooms/name operation on room resource
 */
export const patchApiJsonRoomsNameMutation = (options?: Partial<Options<PatchApiJsonRoomsNameData>>): UseMutationOptions<PatchApiJsonRoomsNameResponse, PatchApiJsonRoomsNameError, Options<PatchApiJsonRoomsNameData>> => {
    const mutationOptions: UseMutationOptions<PatchApiJsonRoomsNameResponse, PatchApiJsonRoomsNameError, Options<PatchApiJsonRoomsNameData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchApiJsonRoomsName({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * /rooms/upsert_with_payers operation on room resource
 */
export const postApiJsonRoomsUpsertWithPayersMutation = (options?: Partial<Options<PostApiJsonRoomsUpsertWithPayersData>>): UseMutationOptions<PostApiJsonRoomsUpsertWithPayersResponse, PostApiJsonRoomsUpsertWithPayersError, Options<PostApiJsonRoomsUpsertWithPayersData>> => {
    const mutationOptions: UseMutationOptions<PostApiJsonRoomsUpsertWithPayersResponse, PostApiJsonRoomsUpsertWithPayersError, Options<PostApiJsonRoomsUpsertWithPayersData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postApiJsonRoomsUpsertWithPayers({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getApiJsonRoomsByIdPayersQueryKey = (options: Options<GetApiJsonRoomsByIdPayersData>) => createQueryKey('getApiJsonRoomsByIdPayers', options);

/**
 * /rooms/:id/payers operation on payer resource
 */
export const getApiJsonRoomsByIdPayersOptions = (options: Options<GetApiJsonRoomsByIdPayersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getApiJsonRoomsByIdPayers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getApiJsonRoomsByIdPayersQueryKey(options)
    });
};

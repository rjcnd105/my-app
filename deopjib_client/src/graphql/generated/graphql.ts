/* eslint-disable */
import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /**
   * The `DateTime` scalar type represents a date and time in the UTC
   * timezone. The DateTime appears in a JSON response as an ISO8601 formatted
   * string, including UTC timezone ("Z"). The parsed date and time string will
   * be converted to UTC if there is an offset.
   */
  DateTime: { input: Date; output: Date; }
  /**
   * The `Json` scalar type represents arbitrary json string data, represented as UTF-8
   * character sequences. The Json type is most often used to represent a free-form
   * human-readable json string.
   */
  Json: { input: { [key: string]: any }; output: { [key: string]: any }; }
};

export type CreateFromWordsInput = {
  words?: InputMaybe<Scalars['String']['input']>;
};

/** The result of the :create_from_words mutation */
export type CreateFromWordsResult = {
  __typename?: 'CreateFromWordsResult';
  /** Any errors generated, if the mutation failed */
  errors: Array<MutationError>;
  /** The successful result of the mutation */
  result?: Maybe<PayItem>;
};

export type CreateRoomInput = {
  name: Scalars['String']['input'];
};

/** The result of the :create_room mutation */
export type CreateRoomResult = {
  __typename?: 'CreateRoomResult';
  /** Any errors generated, if the mutation failed */
  errors: Array<MutationError>;
  /** The successful result of the mutation */
  result?: Maybe<Room>;
};

/** A keyset page of :pay_item */
export type KeysetPageOfPayItem = {
  __typename?: 'KeysetPageOfPayItem';
  /** Total count on all pages */
  count?: Maybe<Scalars['Int']['output']>;
  /** The last keyset in the results */
  endKeyset?: Maybe<Scalars['String']['output']>;
  /** The records contained in the page */
  results?: Maybe<Array<PayItem>>;
  /** The first keyset in the results */
  startKeyset?: Maybe<Scalars['String']['output']>;
};

/** An error generated by a failed mutation */
export type MutationError = {
  __typename?: 'MutationError';
  /** An error code for the given error */
  code?: Maybe<Scalars['String']['output']>;
  /** The field or fields that produced the error */
  fields?: Maybe<Array<Scalars['String']['output']>>;
  /** The human readable error message */
  message?: Maybe<Scalars['String']['output']>;
  /** A shorter error message, with vars not replaced */
  shortMessage?: Maybe<Scalars['String']['output']>;
  /** Replacements for the short message */
  vars?: Maybe<Scalars['Json']['output']>;
};

export type PayItem = {
  __typename?: 'PayItem';
  amount?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
};

export type PayItemFilterAmount = {
  eq?: InputMaybe<Scalars['Int']['input']>;
  greaterThan?: InputMaybe<Scalars['Int']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['Int']['input']>;
  in?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  isNil?: InputMaybe<Scalars['Boolean']['input']>;
  lessThan?: InputMaybe<Scalars['Int']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['Int']['input']>;
  notEq?: InputMaybe<Scalars['Int']['input']>;
};

export type PayItemFilterId = {
  eq?: InputMaybe<Scalars['ID']['input']>;
  greaterThan?: InputMaybe<Scalars['ID']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['ID']['input']>;
  in?: InputMaybe<Array<Scalars['ID']['input']>>;
  isNil?: InputMaybe<Scalars['Boolean']['input']>;
  lessThan?: InputMaybe<Scalars['ID']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['ID']['input']>;
  notEq?: InputMaybe<Scalars['ID']['input']>;
};

export type PayItemFilterInput = {
  amount?: InputMaybe<PayItemFilterAmount>;
  and?: InputMaybe<Array<PayItemFilterInput>>;
  id?: InputMaybe<PayItemFilterId>;
  name?: InputMaybe<PayItemFilterName>;
  not?: InputMaybe<Array<PayItemFilterInput>>;
  or?: InputMaybe<Array<PayItemFilterInput>>;
};

export type PayItemFilterName = {
  eq?: InputMaybe<Scalars['String']['input']>;
  greaterThan?: InputMaybe<Scalars['String']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['String']['input']>;
  ilike?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  isNil?: InputMaybe<Scalars['Boolean']['input']>;
  lessThan?: InputMaybe<Scalars['String']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['String']['input']>;
  like?: InputMaybe<Scalars['String']['input']>;
  notEq?: InputMaybe<Scalars['String']['input']>;
};

export type PayItemSortField =
  | 'AMOUNT'
  | 'ID'
  | 'NAME';

export type PayItemSortInput = {
  field: PayItemSortField;
  order?: InputMaybe<SortOrder>;
};

export type PutPayersInRoomInput = {
  payers?: InputMaybe<Array<RoomPutPayersInRoomPayersInput>>;
};

/** The result of the :put_payers_in_room mutation */
export type PutPayersInRoomResult = {
  __typename?: 'PutPayersInRoomResult';
  /** Any errors generated, if the mutation failed */
  errors: Array<MutationError>;
  /** The successful result of the mutation */
  result?: Maybe<Room>;
};

export type Room = {
  __typename?: 'Room';
  countsOfPayers: Scalars['Int']['output'];
  expirationAt?: Maybe<Scalars['DateTime']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  shortId?: Maybe<Scalars['String']['output']>;
};

export type RoomFilterCountsOfPayers = {
  eq?: InputMaybe<Scalars['Int']['input']>;
  greaterThan?: InputMaybe<Scalars['Int']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['Int']['input']>;
  in?: InputMaybe<Array<InputMaybe<Scalars['Int']['input']>>>;
  isNil?: InputMaybe<Scalars['Boolean']['input']>;
  lessThan?: InputMaybe<Scalars['Int']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['Int']['input']>;
  notEq?: InputMaybe<Scalars['Int']['input']>;
};

export type RoomFilterExpirationAt = {
  eq?: InputMaybe<Scalars['DateTime']['input']>;
  greaterThan?: InputMaybe<Scalars['DateTime']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['DateTime']['input']>;
  in?: InputMaybe<Array<InputMaybe<Scalars['DateTime']['input']>>>;
  isNil?: InputMaybe<Scalars['Boolean']['input']>;
  lessThan?: InputMaybe<Scalars['DateTime']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['DateTime']['input']>;
  notEq?: InputMaybe<Scalars['DateTime']['input']>;
};

export type RoomFilterId = {
  eq?: InputMaybe<Scalars['ID']['input']>;
  greaterThan?: InputMaybe<Scalars['ID']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['ID']['input']>;
  in?: InputMaybe<Array<Scalars['ID']['input']>>;
  isNil?: InputMaybe<Scalars['Boolean']['input']>;
  lessThan?: InputMaybe<Scalars['ID']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['ID']['input']>;
  notEq?: InputMaybe<Scalars['ID']['input']>;
};

export type RoomFilterInput = {
  and?: InputMaybe<Array<RoomFilterInput>>;
  countsOfPayers?: InputMaybe<RoomFilterCountsOfPayers>;
  expirationAt?: InputMaybe<RoomFilterExpirationAt>;
  id?: InputMaybe<RoomFilterId>;
  name?: InputMaybe<RoomFilterName>;
  not?: InputMaybe<Array<RoomFilterInput>>;
  or?: InputMaybe<Array<RoomFilterInput>>;
  shortId?: InputMaybe<RoomFilterShortId>;
};

export type RoomFilterName = {
  eq?: InputMaybe<Scalars['String']['input']>;
  greaterThan?: InputMaybe<Scalars['String']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['String']['input']>;
  ilike?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  isNil?: InputMaybe<Scalars['Boolean']['input']>;
  lessThan?: InputMaybe<Scalars['String']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['String']['input']>;
  like?: InputMaybe<Scalars['String']['input']>;
  notEq?: InputMaybe<Scalars['String']['input']>;
};

export type RoomFilterShortId = {
  eq?: InputMaybe<Scalars['String']['input']>;
  greaterThan?: InputMaybe<Scalars['String']['input']>;
  greaterThanOrEqual?: InputMaybe<Scalars['String']['input']>;
  ilike?: InputMaybe<Scalars['String']['input']>;
  in?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  isNil?: InputMaybe<Scalars['Boolean']['input']>;
  lessThan?: InputMaybe<Scalars['String']['input']>;
  lessThanOrEqual?: InputMaybe<Scalars['String']['input']>;
  like?: InputMaybe<Scalars['String']['input']>;
  notEq?: InputMaybe<Scalars['String']['input']>;
};

export type RoomPutPayersInRoomPayersInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type RoomSortField =
  | 'COUNTS_OF_PAYERS'
  | 'EXPIRATION_AT'
  | 'ID'
  | 'NAME'
  | 'SHORT_ID';

export type RoomSortInput = {
  field: RoomSortField;
  order?: InputMaybe<SortOrder>;
};

export type RootMutationType = {
  __typename?: 'RootMutationType';
  createFromWords: CreateFromWordsResult;
  createRoom: CreateRoomResult;
  putPayersInRoom: PutPayersInRoomResult;
  updateRoomName: UpdateRoomNameResult;
};


export type RootMutationTypeCreateFromWordsArgs = {
  input?: InputMaybe<CreateFromWordsInput>;
};


export type RootMutationTypeCreateRoomArgs = {
  input: CreateRoomInput;
};


export type RootMutationTypePutPayersInRoomArgs = {
  id: Scalars['ID']['input'];
  input?: InputMaybe<PutPayersInRoomInput>;
};


export type RootMutationTypeUpdateRoomNameArgs = {
  id: Scalars['ID']['input'];
  input?: InputMaybe<UpdateRoomNameInput>;
};

export type RootQueryType = {
  __typename?: 'RootQueryType';
  getPayItem?: Maybe<PayItem>;
  getPayItemList?: Maybe<KeysetPageOfPayItem>;
  room: Room;
  rooms: Array<Room>;
  /**
   * Hello! This is a sample query to verify that AshGraphql has been set up correctly.
   * Remove me once you have a query of your own!
   */
  sayHello?: Maybe<Scalars['String']['output']>;
};


export type RootQueryTypeGetPayItemArgs = {
  id: Scalars['ID']['input'];
};


export type RootQueryTypeGetPayItemListArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  filter?: InputMaybe<PayItemFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  sort?: InputMaybe<Array<InputMaybe<PayItemSortInput>>>;
};


export type RootQueryTypeRoomArgs = {
  filter?: InputMaybe<RoomFilterInput>;
  shortId?: InputMaybe<Scalars['String']['input']>;
};


export type RootQueryTypeRoomsArgs = {
  filter?: InputMaybe<RoomFilterInput>;
  sort?: InputMaybe<Array<InputMaybe<RoomSortInput>>>;
};

export type SortOrder =
  | 'ASC'
  | 'ASC_NULLS_FIRST'
  | 'ASC_NULLS_LAST'
  | 'DESC'
  | 'DESC_NULLS_FIRST'
  | 'DESC_NULLS_LAST';

export type UpdateRoomNameInput = {
  name?: InputMaybe<Scalars['String']['input']>;
};

/** The result of the :update_room_name mutation */
export type UpdateRoomNameResult = {
  __typename?: 'UpdateRoomNameResult';
  /** Any errors generated, if the mutation failed */
  errors: Array<MutationError>;
  /** The successful result of the mutation */
  result?: Maybe<Room>;
};

export type RoomQueryVariables = Exact<{
  shortId: Scalars['String']['input'];
}>;


export type RoomQuery = { __typename?: 'RootQueryType', room: { __typename?: 'Room', shortId?: string | null, name: string, countsOfPayers: number } };


export const RoomDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"Room"},"variableDefinitions":[{"kind":"VariableDefinition","variable":{"kind":"Variable","name":{"kind":"Name","value":"shortId"}},"type":{"kind":"NonNullType","type":{"kind":"NamedType","name":{"kind":"Name","value":"String"}}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"room"},"arguments":[{"kind":"Argument","name":{"kind":"Name","value":"shortId"},"value":{"kind":"Variable","name":{"kind":"Name","value":"shortId"}}}],"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"shortId"}},{"kind":"Field","name":{"kind":"Name","value":"name"}},{"kind":"Field","name":{"kind":"Name","value":"countsOfPayers"}}]}}]}}]} as unknown as DocumentNode<RoomQuery, RoomQueryVariables>;
{"compilerOptions":{"css":"external","dev":true,"hmr":true},"experimental":{"sendWarningsToBrowser":true},"extensions":[".svelte"],"preprocess":[{"markup":"async ({ content, filename }) => {\n        if (transformers.replace) {\n            const transformed = await (0, exports.transform)('replace', transformers.replace, {\n                content,\n                markup: content,\n                filename,\n            });\n            content = transformed.code;\n        }\n        return (0, markup_1.transformMarkup)({ content, filename }, markupTransformer, {\n            // we only pass the markupTagName because the rest of options\n            // is fetched internally by the `markupTransformer`\n            markupTagName,\n        });\n    }","script":"async ({ content, attributes, markup: fullMarkup, filename, }) => {\n        const transformResult = await scriptTransformer({\n            content,\n            attributes,\n            markup: fullMarkup,\n            filename,\n        });\n        let { code, map, dependencies, diagnostics } = transformResult;\n        if (transformers.babel) {\n            const transformed = await (0, exports.transform)('babel', getTransformerOptions('babel'), { content: code, markup: fullMarkup, map, filename, attributes });\n            code = transformed.code;\n            map = transformed.map;\n            dependencies = (0, utils_1.concat)(dependencies, transformed.dependencies);\n            diagnostics = (0, utils_1.concat)(diagnostics, transformed.diagnostics);\n        }\n        return { code, map, dependencies, diagnostics };\n    }","style":"async ({ content, attributes, markup: fullMarkup, filename, }) => {\n        const transformResult = await cssTransformer({\n            content,\n            attributes,\n            markup: fullMarkup,\n            filename,\n        });\n        let { code, map, dependencies } = transformResult;\n        const hasPostcss = await (0, utils_1.hasDepInstalled)('postcss');\n        // istanbul ignore else\n        if (hasPostcss) {\n            if (transformers.postcss) {\n                const { alias, lang } = (0, language_1.getLanguage)(attributes);\n                const postcssOptions = getTransformerOptions('postcss', (0, language_1.isAliasOf)(alias, lang) ? alias : null, \n                // todo: this seems wrong and ugly\n                { ignoreAliasOverride: true });\n                const transformed = await (0, exports.transform)('postcss', postcssOptions, {\n                    content: code,\n                    markup: fullMarkup,\n                    map,\n                    filename,\n                    attributes,\n                });\n                code = transformed.code;\n                map = transformed.map;\n                dependencies = (0, utils_1.concat)(dependencies, transformed.dependencies);\n            }\n            const transformed = await (0, exports.transform)('globalStyle', getTransformerOptions('globalStyle'), { content: code, markup: fullMarkup, map, filename, attributes });\n            code = transformed.code;\n            map = transformed.map;\n        }\n        else if ('global' in attributes) {\n            console.warn(`[svelte-preprocess] 'global' attribute found, but 'postcss' is not installed. 'postcss' is used to walk through the CSS and transform any necessary selector.`);\n        }\n        return { code, map, dependencies };\n    }"},{"name":"vite-preprocess","style":"async ({ attributes, content, filename = '' }) => {\n\t\tconst ext = attributes.lang ? `.${attributes.lang}` : '.css';\n\t\tif (attributes.lang && !isCSSRequest(ext)) return;\n\t\tif (!cssTransform) {\n\t\t\tcssTransform = createCssTransform(style, config).then((t) => (cssTransform = t));\n\t\t}\n\t\tconst transform = await cssTransform;\n\t\tconst suffix = `${lang_sep}${ext}`;\n\t\tconst moduleId = `${filename}${suffix}`;\n\t\tconst { code, map, deps } = await transform(content, moduleId);\n\t\tremoveLangSuffix(map, suffix);\n\t\tmapToRelative(map, filename);\n\t\tconst dependencies = deps ? Array.from(deps).filter((d) => !d.endsWith(suffix)) : undefined;\n\t\treturn {\n\t\t\tcode,\n\t\t\tmap: map ?? undefined,\n\t\t\tdependencies\n\t\t};\n\t}"}]}
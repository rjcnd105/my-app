import type { MaybeGetter } from "../types";
import type { ComputePositionConfig } from "@floating-ui/dom";
export type TooltipProps = {
    /**
     * If the Tooltip is open.
     *
     * When passing a getter, it will be used as source of truth,
     * meaning that the value only changes when the getter returns a new value.
     *
     * Otherwise, if passing a static value, it'll serve as the default value.
     *
     * @default false
     */
    open?: MaybeGetter<boolean | undefined>;
    /**
     * Called when the value is supposed to change.
     */
    onOpenChange?: (value: boolean) => void;
    /**
     * Size of tooltip arrow in pixels.
     *
     * @default 8
     */
    arrowSize?: MaybeGetter<number | undefined>;
    /**
     * If `true`, tooltip will close if trigger is pressed.
     *
     * @default true
     */
    closeOnPointerDown?: MaybeGetter<boolean | undefined>;
    /**
     * Tooltip open delay in milliseconds.
     *
     * @default 1000
     */
    openDelay?: MaybeGetter<number | undefined>;
    /**
     * Tooltip close delay in milliseconds.
     *
     * @default 0
     */
    closeDelay?: MaybeGetter<number | undefined>;
    /**
     * Options to be passed to Floating UI's `computePosition`
     *
     * @see https://floating-ui.com/docs/computePosition
     */
    computePositionOptions?: MaybeGetter<Partial<ComputePositionConfig> | undefined>;
    /**
     * If the popover visibility should be controlled by the user.
     *
     * @default false
     */
    forceVisible?: MaybeGetter<boolean | undefined>;
    /**
     * If `true`, leaving trigger will close the tooltip.
     *
     * @default false
     */
    disableHoverableContent?: MaybeGetter<boolean | undefined>;
};
export declare class Tooltip {
    #private;
    computePositionOptions: Partial<{
        placement?: import("@floating-ui/dom").Placement | undefined;
        strategy?: import("@floating-ui/dom").Strategy | undefined;
        middleware?: Array<import("@floating-ui/dom").Middleware | null | undefined | false> | undefined;
        platform?: import("@floating-ui/dom").Platform | undefined;
    }> | {};
    closeOnPointerDown: boolean;
    openDelay: number;
    closeDelay: number;
    disableHoverableContent: boolean;
    arrowSize: number;
    forceVisible: boolean;
    /** State */
    isVisible: boolean;
    constructor(props?: TooltipProps);
    get open(): boolean;
    set open(value: boolean);
    get trigger(): {
        readonly onfocusout: () => Promise<void>;
        readonly "data-melt-tooltip-trigger": "";
        readonly id: string;
        readonly "aria-describedby": string;
        readonly "data-open": "" | undefined;
        readonly onpointerdown: () => void;
        readonly onpointerenter: (e: PointerEvent & {
            currentTarget: EventTarget & HTMLElement;
        }) => void;
        readonly onpointerleave: (e: PointerEvent & {
            currentTarget: EventTarget & HTMLElement;
        }) => void;
        readonly onfocus: () => void;
        readonly onblur: () => void;
    };
    get content(): {
        readonly onfocusout: () => Promise<void>;
        readonly "data-melt-tooltip-content": "";
        readonly id: string;
        readonly popover: "manual";
        readonly role: "tooltip";
        readonly tabindex: -1;
        readonly style: "overflow: visible;";
        readonly inert: boolean;
        readonly "data-open": "" | undefined;
        readonly onpointerenter: () => void;
        readonly onpointerleave: () => void;
        readonly onpointerdown: () => void;
    };
    get arrow(): {
        readonly "data-melt-tooltip-arrow": "";
        readonly id: string;
        readonly "data-arrow": "";
        readonly "data-open": "" | undefined;
        readonly style: `position: absolute; width: var(--arrow-size, ${number}px); height: var(--arrow-size, ${number}px);`;
    };
}

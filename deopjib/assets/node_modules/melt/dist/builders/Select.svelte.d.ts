import type { MaybeGetter } from "../types";
import { type MaybeMultiple, type OnMultipleChange } from "../utils/selection-state.svelte";
import { BasePopover, type PopoverProps } from "./Popover.svelte";
declare const createIds: () => {
    trigger: string;
    content: string;
    option: string;
};
export type SelectProps<T extends string, Multiple extends boolean = false> = Omit<PopoverProps, "sameWidth"> & {
    /**
     * If `true`, multiple options can be selected at the same time.
     *
     * @default false
     */
    multiple?: MaybeGetter<Multiple | undefined>;
    /**
     * The value for the Select.
     *
     * When passing a getter, it will be used as source of truth,
     * meaning that the value only changes when the getter returns a new value.
     *
     * Otherwise, if passing a static value, it'll serve as the default value.
     *
     *
     * @default false
     */
    value?: MaybeMultiple<T, Multiple>;
    /**
     * Called when the value is supposed to change.
     */
    onValueChange?: OnMultipleChange<T, Multiple>;
    /**
     * How many time (in ms) the typeahead string is held before it is cleared
     * @default 500
     */
    typeaheadTimeout?: MaybeGetter<number | undefined>;
    /**
     * If the content should have the same width as the trigger
     *
     * @default true
     */
    sameWidth?: MaybeGetter<boolean | undefined>;
};
export declare class Select<T extends string, Multiple extends boolean = false> extends BasePopover {
    #private;
    multiple: Multiple extends null | undefined ? Multiple | undefined : Multiple | Exclude<Multiple, null | undefined>;
    highlighted: T | null;
    ids: ReturnType<typeof createIds> & BasePopover["ids"];
    readonly typeaheadTimeout: number;
    readonly typeahead: (letter: string) => {
        value: T;
        current: boolean;
    } | undefined;
    constructor(props?: SelectProps<T, Multiple>);
    get value(): import("../utils/selection-state.svelte").SelectionStateValue<T, Multiple>;
    set value(value: import("../utils/selection-state.svelte").SelectionStateValue<T, Multiple>);
    get valueAsString(): string;
    isSelected: (value: T) => boolean;
    select: (value: T) => void;
    get trigger(): {
        readonly onfocusout: () => Promise<void>;
        readonly id: string;
        readonly popovertarget: string;
        readonly onclick: (e: Event) => void;
    } & {
        "data-melt-select-trigger": string;
        role: string;
        "aria-expanded": boolean;
        "aria-controls": string;
        "aria-owns": string;
        onkeydown: (e: KeyboardEvent) => void;
    };
    get content(): {
        readonly onfocusout: () => Promise<void>;
        readonly id: string;
        readonly popover: "manual";
        readonly ontoggle: (e: ToggleEvent & {
            currentTarget: EventTarget & HTMLElement;
        }) => void;
        readonly tabindex: -1;
        readonly inert: boolean;
        readonly "data-open": "" | undefined;
    } & {
        readonly "data-melt-select-content": "";
        readonly role: "listbox";
        readonly "aria-expanded": boolean;
        readonly "aria-activedescendant": string | undefined;
        readonly onkeydown: (e: KeyboardEvent) => void;
    };
    getOptionId(value: T): string;
    getOption(value: T): {
        readonly "data-melt-select-option": "";
        readonly "data-value": T extends true ? "" : T extends false ? undefined : T;
        readonly "aria-hidden": true | undefined;
        readonly "aria-selected": boolean;
        readonly "data-highlighted": "" | undefined;
        readonly role: "option";
        readonly onmouseover: () => void;
        readonly onclick: () => void;
    };
}
export {};

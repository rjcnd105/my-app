import { Synced } from "../Synced.svelte";
import { dataAttr } from "../utils/attribute";
import { addEventListener } from "../utils/event";
import { extract } from "../utils/extract";
import { createDataIds } from "../utils/identifiers";
import { isFunction, isHtmlElement } from "../utils/is";
import { deepMerge } from "../utils/merge";
import { safelyHidePopover, safelyShowPopover } from "../utils/popover";
import { autoUpdate, computePosition, flip, offset, shift, size, } from "@floating-ui/dom";
import { nanoid } from "nanoid";
import { useEventListener } from "runed";
const dataIds = createDataIds("popover", ["trigger", "content"]);
export const isCloseOnOutsideClickCheck = (value) => isFunction(value) && value.length === 1;
export class BasePopover {
    ids = $state({ invoker: nanoid(), popover: nanoid() });
    /* Props */
    #props;
    forceVisible = $derived(extract(this.#props.forceVisible, false));
    computePositionOptions = $derived(extract(this.#props.computePositionOptions, {}));
    closeOnEscape = $derived(extract(this.#props.closeOnEscape, true));
    sameWidth = $derived(extract(this.#props.sameWidth, false));
    closeOnOutsideClick = $derived(extract(this.#props.closeOnOutsideClick, true));
    /* State */
    #open;
    constructor(props = {}) {
        this.#open = new Synced({
            value: props.open,
            onChange: props.onOpenChange,
            defaultValue: false,
        });
        this.#props = props;
    }
    get open() {
        return this.#open.current;
    }
    set open(value) {
        this.#open.current = value;
    }
    #shouldClose(el) {
        if (this.closeOnOutsideClick === false)
            return false;
        if (isFunction(this.closeOnOutsideClick)) {
            return isCloseOnOutsideClickCheck(this.closeOnOutsideClick)
                ? this.closeOnOutsideClick(el) // Pass target if it's the correct type
                : this.closeOnOutsideClick(); // Otherwise, call without arguments
        }
        return true;
    }
    get sharedProps() {
        return {
            onfocusout: async () => {
                await new Promise((r) => setTimeout(r));
                const contentEl = document.getElementById(this.ids.popover);
                const triggerEl = document.getElementById(this.ids.invoker);
                const activeEl = document.activeElement;
                if (!activeEl ||
                    contentEl?.contains(activeEl) ||
                    triggerEl?.contains(activeEl) ||
                    !this.#shouldClose(activeEl) // Hack, we should probably have a focusOut prop
                ) {
                    return;
                }
                this.open = false;
            },
        };
    }
    /** The trigger that toggles the value. */
    getInvoker() {
        return {
            id: this.ids.invoker,
            popovertarget: this.ids.popover,
            onclick: (e) => {
                e.preventDefault();
                this.open = !this.open;
            },
            ...this.sharedProps,
        };
    }
    getPopover() {
        // Show and hide popover based on open state
        $effect(() => {
            const el = document.getElementById(this.ids.popover);
            if (!isHtmlElement(el)) {
                return;
            }
            if (this.open || this.forceVisible) {
                // Check if there's a parent popover. If so, only open if the parent's open.
                // This is to guarantee correct layering.
                const parent = isHtmlElement(el.parentNode)
                    ? el.parentNode.closest(`[${dataIds.content}]`)
                    : undefined;
                if (!isHtmlElement(parent)) {
                    safelyShowPopover(el);
                    return;
                }
                if (parent.dataset.open !== undefined)
                    safelyShowPopover(el);
                return addEventListener(parent, "toggle", async (e) => {
                    await new Promise((r) => setTimeout(r));
                    const isOpen = e.newState === "open";
                    if (isOpen) {
                        safelyShowPopover(el);
                    }
                    else {
                        safelyHidePopover(el);
                    }
                });
            }
            else {
                safelyHidePopover(el);
            }
        });
        // Floating UI
        const compute = () => {
            const contentEl = document.getElementById(this.ids.popover);
            const triggerEl = document.getElementById(this.ids.invoker);
            if (!isHtmlElement(contentEl) || !isHtmlElement(triggerEl)) {
                return;
            }
            const baseOptions = {
                middleware: [
                    shift(),
                    flip(),
                    offset({ mainAxis: 8 }),
                    this.sameWidth
                        ? size({
                            apply({ rects, elements }) {
                                Object.assign(elements.floating?.style ?? {}, {
                                    width: `${rects.reference.width}px`,
                                    minWidth: `${rects.reference.width}px`,
                                });
                            },
                        })
                        : undefined,
                ],
            };
            computePosition(triggerEl, contentEl, deepMerge(baseOptions, this.computePositionOptions)).then(({ x, y, placement }) => {
                const transformOriginMap = {
                    top: "bottom center",
                    "top-start": "bottom left",
                    "top-end": "bottom right",
                    bottom: "top center",
                    "bottom-start": "top left",
                    "bottom-end": "top right",
                    left: "center center",
                    "left-start": "top left",
                    "left-end": "bottom left",
                    right: "center center",
                    "right-start": "top right",
                    "right-end": "bottom right",
                };
                Object.assign(contentEl.style, {
                    left: `${x}px`,
                    top: `${y}px`,
                    position: "absolute",
                });
                contentEl.style.transformOrigin = transformOriginMap[placement];
                contentEl.dataset.side = placement;
            });
        };
        $effect(() => {
            const contentEl = document.getElementById(this.ids.popover);
            const triggerEl = document.getElementById(this.ids.invoker);
            if (!isHtmlElement(contentEl) || !isHtmlElement(triggerEl)) {
                return;
            }
            return autoUpdate(triggerEl, contentEl, compute);
        });
        useEventListener(() => document, "keydown", (e) => {
            if (!this.closeOnEscape)
                return;
            const el = document.getElementById(this.ids.popover);
            if (e.key !== "Escape" || !this.open || !isHtmlElement(el))
                return;
            e.preventDefault();
            const openPopovers = [...el.querySelectorAll("[popover]")].filter((child) => {
                if (!isHtmlElement(child))
                    return false;
                // If child is a Melt popover, check if it's open
                if (child.matches(`[${dataIds.content}]`))
                    return child.dataset.open !== undefined;
                return child.matches(":popover-open");
            });
            if (openPopovers.length)
                return;
            // Set timeout to give time to all event listeners to run
            setTimeout(() => (this.open = false));
        });
        useEventListener(() => document, "click", (e) => {
            if (!this.open)
                return; // Exit early if not open
            const contentEl = document.getElementById(this.ids.popover);
            const triggerEl = document.getElementById(this.ids.invoker);
            if (!contentEl || !triggerEl)
                return; // Exit if elements are missing
            const target = e.target;
            const isInsideContent = contentEl.contains(target);
            const isInsideTrigger = triggerEl.contains(target);
            if (isInsideContent || isInsideTrigger)
                return; // Exit if clicked inside
            if (this.#shouldClose(target))
                this.open = false;
        });
        return {
            id: this.ids.popover,
            popover: "manual",
            ontoggle: (e) => {
                const newOpen = e.newState === "open";
                if (this.open !== newOpen && newOpen === false) {
                    this.open = newOpen;
                }
            },
            // Needed so it receives focus on click, but not on tab, because of focus out
            tabindex: -1,
            inert: !this.open,
            "data-open": dataAttr(this.open),
            ...this.sharedProps,
        };
    }
}
export class Popover extends BasePopover {
    constructor(props = {}) {
        super({ ...props });
        this.ids = { ...this.ids, trigger: this.ids.invoker, content: this.ids.popover };
    }
    /** The trigger that toggles the value. */
    get trigger() {
        return Object.assign(this.getInvoker(), {
            [dataIds.trigger]: "",
        });
    }
    get content() {
        return Object.assign(this.getPopover(), {
            [dataIds.content]: "",
        });
    }
}

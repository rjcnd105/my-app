schema {
  mutation: RootMutationType
  query: RootQueryType
}

input RoomPutPayersInRoomPayersInput {
  id: ID
  name: String
}

"The result of the :create_from_words mutation"
type CreateFromWordsResult {
  "The successful result of the mutation"
  result: PayItem

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateFromWordsInput {
  words: String
}

enum PayItemSortField {
  ID
  NAME
  AMOUNT
}

"A keyset page of :pay_item"
type KeysetPageOfPayItem {
  "Total count on all pages"
  count: Int

  "The records contained in the page"
  results: [PayItem!]

  "The first keyset in the results"
  startKeyset: String

  "The last keyset in the results"
  endKeyset: String
}

input PayItemFilterAmount {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input PayItemFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input PayItemFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input PayItemFilterInput {
  and: [PayItemFilterInput!]
  or: [PayItemFilterInput!]
  not: [PayItemFilterInput!]
  id: PayItemFilterId
  name: PayItemFilterName
  amount: PayItemFilterAmount
}

input PayItemSortInput {
  order: SortOrder
  field: PayItemSortField!
}

type PayItem {
  id: ID!
  name: String
  amount: Int
}

"The result of the :put_payers_in_room mutation"
type PutPayersInRoomResult {
  "The successful result of the mutation"
  result: Room

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input PutPayersInRoomInput {
  payers: [RoomPutPayersInRoomPayersInput!]
}

"The result of the :update_room_name mutation"
type UpdateRoomNameResult {
  "The successful result of the mutation"
  result: Room

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input UpdateRoomNameInput {
  name: String
}

"The result of the :create_room mutation"
type CreateRoomResult {
  "The successful result of the mutation"
  result: Room

  "Any errors generated, if the mutation failed"
  errors: [MutationError!]!
}

input CreateRoomInput {
  name: String!
}

enum RoomSortField {
  ID
  NAME
  EXPIRATION_AT
  COUNTS_OF_PAYERS
}

"A keyset page of :room"
type KeysetPageOfRoom {
  "Total count on all pages"
  count: Int

  "The records contained in the page"
  results: [Room!]

  "The first keyset in the results"
  startKeyset: String

  "The last keyset in the results"
  endKeyset: String
}

input RoomFilterCountsOfPayers {
  isNil: Boolean
  eq: Int
  notEq: Int
  in: [Int]
  lessThan: Int
  greaterThan: Int
  lessThanOrEqual: Int
  greaterThanOrEqual: Int
}

input RoomFilterExpirationAt {
  isNil: Boolean
  eq: DateTime
  notEq: DateTime
  in: [DateTime]
  lessThan: DateTime
  greaterThan: DateTime
  lessThanOrEqual: DateTime
  greaterThanOrEqual: DateTime
}

input RoomFilterName {
  isNil: Boolean
  eq: String
  notEq: String
  in: [String!]
  lessThan: String
  greaterThan: String
  lessThanOrEqual: String
  greaterThanOrEqual: String
  like: String
  ilike: String
}

input RoomFilterId {
  isNil: Boolean
  eq: ID
  notEq: ID
  in: [ID!]
  lessThan: ID
  greaterThan: ID
  lessThanOrEqual: ID
  greaterThanOrEqual: ID
}

input RoomFilterInput {
  and: [RoomFilterInput!]
  or: [RoomFilterInput!]
  not: [RoomFilterInput!]
  id: RoomFilterId
  name: RoomFilterName
  expirationAt: RoomFilterExpirationAt
  countsOfPayers: RoomFilterCountsOfPayers
}

input RoomSortInput {
  order: SortOrder
  field: RoomSortField!
}

type Room {
  id: ID!
  name: String!
  expirationAt: DateTime
  countsOfPayers: Int!
}

enum SortOrder {
  DESC
  DESC_NULLS_FIRST
  DESC_NULLS_LAST
  ASC
  ASC_NULLS_FIRST
  ASC_NULLS_LAST
}

"An error generated by a failed mutation"
type MutationError {
  "The human readable error message"
  message: String

  "A shorter error message, with vars not replaced"
  shortMessage: String

  "Replacements for the short message"
  vars: Json

  "An error code for the given error"
  code: String

  "The field or fields that produced the error"
  fields: [String!]
}

type RootQueryType {
  """
  Hello! This is a sample query to verify that AshGraphql has been set up correctly.
  Remove me once you have a query of your own!
  """
  sayHello: String

  getRoom(
    "The id of the record"
    id: ID!
  ): Room

  listRooms(
    "How to sort the records in the response"
    sort: [RoomSortInput]

    "A filter to limit the results"
    filter: RoomFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): KeysetPageOfRoom

  getPayItem(
    "The id of the record"
    id: ID!
  ): PayItem

  getPayItemList(
    "How to sort the records in the response"
    sort: [PayItemSortInput]

    "A filter to limit the results"
    filter: PayItemFilterInput

    "The number of records to return from the beginning. Maximum 250"
    first: Int

    "Show records before the specified keyset."
    before: String

    "Show records after the specified keyset."
    after: String

    "The number of records to return to the end. Maximum 250"
    last: Int
  ): KeysetPageOfPayItem
}

type RootMutationType {
  createRoom(input: CreateRoomInput!): CreateRoomResult!
  updateRoomName(id: ID!, input: UpdateRoomNameInput): UpdateRoomNameResult!
  putPayersInRoom(id: ID!, input: PutPayersInRoomInput): PutPayersInRoomResult!
  createFromWords(input: CreateFromWordsInput): CreateFromWordsResult!
}

"""
The `Json` scalar type represents arbitrary json string data, represented as UTF-8
character sequences. The Json type is most often used to represent a free-form
human-readable json string.
"""
scalar Json

"""
The `DateTime` scalar type represents a date and time in the UTC
timezone. The DateTime appears in a JSON response as an ISO8601 formatted
string, including UTC timezone ("Z"). The parsed date and time string will
be converted to UTC if there is an offset.
"""
scalar DateTime
